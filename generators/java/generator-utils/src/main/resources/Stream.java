/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.cohere.api.core;

import org.jetbrains.annotations.NotNull;

import java.io.Reader;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Scanner;

/**
 * The {@code Stream} class implements {@link Iterable} to provide a simple mechanism for reading and parsing
 * objects of a given type from data streamed via a {@link Reader} using a specified delimiter.
 * <p>
 * {@code Stream} assumes that data is being pushed to the provided {@link Reader} asynchronously and utilizes a
 * {@code Scanner} to block during iteration if the next object is not available.
 *
 * @param <T> The type of objects in the stream.
 */
public final class Stream<T> implements Iterable<T> {
    /**
     * The {@link Class} of the objects in the stream.
     */
    private final Class<T> valueType;
    /**
     * The {@link Scanner} used for reading from the input stream and blocking when needed during iteration.
     */
    private final Scanner scanner;

    private Options options;

    private StreamType streamType;

    /**
     * The type of stream to be interpreted.
     */
    public enum StreamType {
        SSE, NEWLINE
    }

    private String DEFAULT_VALUE_PREFIX = "data: ";
    private String DEFAULT_VALUE_TERMINATOR = "[DONE]";
    private String DEFAULT_VALUE_DELIMITER = "\n";

    /**
     * Constructs a new {@code Stream} with the specified value type, reader, and delimiter.
     *
     * @param valueType The class of the objects in the stream.
     * @param reader    The reader that provides the streamed data.
     * @param delimiter The delimiter used to separate elements in the stream.
     */
    public Stream(Class<T> valueType, Reader reader, String delimiter) {
        this.scanner = new Scanner(reader).useDelimiter(delimiter);
        this.valueType = valueType;
    }

    /**
     * Constructs a new {@code Stream} with the specified value type, reader, and delimiter.
     *
     * @param valueType The class of the objects in the stream.
     * @param reader    The reader that provides the streamed data.
     * @param options   The options that determine how the stream is to be interpreted and contains prefix, delimiter, and terminator values.
     * @param streamType The type of stream to be interpreted. The value here should come from {@link StreamType}
     * 
     * @see StreamType
     * @see Options
     */
    public Stream(Class<T> valueType, Reader reader, Options options, StreamType streamType) {
        this.streamType = Objects.requireNonNullElse(streamType, StreamType.NEWLINE);
        this.options = Objects.requireNonNullElse(options, new Options(DEFAULT_VALUE_PREFIX, DEFAULT_VALUE_DELIMITER, DEFAULT_VALUE_TERMINATOR));
        this.scanner = new Scanner(reader).useDelimiter(this.options.delimiter);
        this.valueType = valueType;

    }

    public static class Options {
        public @NotNull String prefix;
        public @NotNull String delimiter;
        public @NotNull String terminator;

        public Options(@NotNull String prefix, @NotNull String delimiter, @NotNull String terminator) {
            this.prefix = prefix;
            this.delimiter = delimiter;
            this.terminator = terminator;
        }
    }

    /**
     * Returns an iterator over the elements in this stream that blocks during iteration when the next object is
     * not yet available.
     *
     * @return An iterator that can be used to traverse the elements in the stream.
     */
    @Override
    public Iterator<T> iterator() {
        return new Iterator<T>() {
            /**
             * Returns {@code true} if there are more elements in the stream.
             * <p>
             * Will block and wait for input if the stream has not ended and the next object is not yet available.
             *
             * @return {@code true} if there are more elements, {@code false} otherwise.
             */
            @Override
            public boolean hasNext() {
                return scanner.hasNext();
            }

            /**
             * Returns the next element in the stream.
             * <p>
             * Will block and wait for input if the stream has not ended and the next object is not yet available.
             *
             * @return The next element in the stream.
             * @throws NoSuchElementException If there are no more elements in the stream.
             */
            @Override
            public T next() {
                if (!scanner.hasNext()) {
                    throw new NoSuchElementException();
                } else {
                    try {
                        if (streamType == StreamType.SSE) {
                            String line = scanner.next();
                            while (scanner.hasNext()) {
                                if (!line.startsWith(options.prefix)) {
                                    line = scanner.next();
                                } else {
                                    break;
                                }
                            }
                            if (line.contains(options.terminator)) {
                                throw new NoSuchElementException();
                            } else {
                                T parsedResponse = ObjectMappers.JSON_MAPPER.readValue(
                                        line.substring(options.prefix.length()), valueType);
                                return parsedResponse;
                            }
                        } else {
                            T parsedResponse = ObjectMappers.JSON_MAPPER.readValue(
                                    scanner.next().trim(), valueType);
                            return parsedResponse;
                        }

                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }
                }
            }

            /**
             * Removing elements from {@code Stream} is not supported.
             *
             * @throws UnsupportedOperationException Always, as removal is not supported.
             */
            @Override
            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
    }
}

# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from ..core.request_options import RequestOptions
from ..core.http_response import HttpResponseStreamManager
from .types.streamed_completion import StreamedCompletion
from ..core.http_response import HttpResponse
from ..core.pydantic_utilities import parse_obj_as
import json
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper
from ..core.http_response import AsyncHttpResponseStreamManager
from ..core.http_response import AsyncHttpResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawCompletionsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def stream(
        self, *, query: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponseStreamManager[StreamedCompletion]:
        """
        Parameters
        ----------
        query : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        HttpResponseStreamManager[StreamedCompletion]
        """

        def _stream_func() -> HttpResponse[typing.Iterator[StreamedCompletion]]:
            with self._client_wrapper.httpx_client.stream(
                "stream",
                method="POST",
                json={
                    "query": query,
                },
                request_options=request_options,
                omit=OMIT,
            ) as _response:
                try:
                    if 200 <= _response.status_code < 300:

                        def _iter() -> typing.Iterator[StreamedCompletion]:
                            for _text in _response.iter_lines():
                                try:
                                    if len(_text) == 0:
                                        continue
                                    yield typing.cast(
                                        StreamedCompletion,
                                        parse_obj_as(
                                            type_=StreamedCompletion,  # type: ignore
                                            object_=json.loads(_text),
                                        ),
                                    )
                                except:
                                    pass
                            return

                        return HttpResponse(response=_response, data=_iter())
                    _response.read()
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(status_code=_response.status_code, body=_response.text)
                raise ApiError(status_code=_response.status_code, body=_response_json)

        return HttpResponseStreamManager(stream_func=_stream_func)


class AsyncRawCompletionsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def stream(
        self, *, query: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponseStreamManager[StreamedCompletion]:
        """
        Parameters
        ----------
        query : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        AsyncHttpResponseStreamManager[StreamedCompletion]
        """

        async def _stream_func() -> AsyncHttpResponse[typing.AsyncIterator[StreamedCompletion]]:
            async with self._client_wrapper.httpx_client.stream(
                "stream",
                method="POST",
                json={
                    "query": query,
                },
                request_options=request_options,
                omit=OMIT,
            ) as _response:
                try:
                    if 200 <= _response.status_code < 300:

                        async def _iter() -> typing.AsyncIterator[StreamedCompletion]:
                            async for _text in _response.aiter_lines():
                                try:
                                    if len(_text) == 0:
                                        continue
                                    yield typing.cast(
                                        StreamedCompletion,
                                        parse_obj_as(
                                            type_=StreamedCompletion,  # type: ignore
                                            object_=json.loads(_text),
                                        ),
                                    )
                                except:
                                    pass
                            return

                        return AsyncHttpResponse(response=_response, data=_iter())
                    await _response.aread()
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(status_code=_response.status_code, body=_response.text)
                raise ApiError(status_code=_response.status_code, body=_response_json)

        return AsyncHttpResponseStreamManager(stream_func=_stream_func)

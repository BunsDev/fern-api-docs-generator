# This file was auto-generated by Fern from our API Definition.

import typing
from typing import Generic, TypeVar
from types import TracebackType

import httpx

T = TypeVar("T")


class HttpResponse(Generic[T]):
    _response: httpx.Response
    _data: T

    def __init__(self, response: httpx.Response, data: T):
        self._response = response
        self._data = data

    @property
    def headers(self) -> typing.Dict[str, str]:
        return dict(self._response.headers)

    @property
    def data(self) -> T:
        return self._data

    def close(self) -> None:
        self._response.close()


class AsyncHttpResponse(Generic[T]):
    _response: httpx.Response
    _data: T

    def __init__(self, response: httpx.Response, data: T):
        self._response = response
        self._data = data

    @property
    def headers(self) -> typing.Dict[str, str]:
        return dict(self._response.headers)

    @property
    def data(self) -> T:
        return self._data

    async def close(self) -> None:
        await self._response.aclose()


class StreamResponseManager(Generic[T]):
    def __init__(self, stream_func: typing.Callable[[], HttpResponse[typing.Iterator[T]]]) -> None:
        self._stream_func = stream_func
        self.__response: typing.Optional[HttpResponse[typing.Iterator[T]]] = None

    def __enter__(self) -> HttpResponse[typing.Iterator[T]]:
        self.__response = self._stream_func()
        return self.__response

    def __exit__(
        self,
        exc_type: typing.Optional[typing.Type[BaseException]],
        exc: typing.Optional[BaseException],
        exc_tb: typing.Optional[TracebackType],
    ) -> None:
        if self.__response is not None:
            self.__response.close()


class AsyncStreamResponseManager(Generic[T]):
    def __init__(
        self, stream_func: typing.Callable[[], typing.Awaitable[AsyncHttpResponse[typing.AsyncIterator[T]]]]
    ) -> None:
        self._stream_func = stream_func
        self.__response: typing.Optional[AsyncHttpResponse[typing.AsyncIterator[T]]] = None

    async def __aenter__(self) -> AsyncHttpResponse[typing.AsyncIterator[T]]:
        self.__response = await self._stream_func()
        return self.__response

    async def __aexit__(
        self,
        exc_type: typing.Optional[typing.Type[BaseException]],
        exc: typing.Optional[BaseException],
        exc_tb: typing.Optional[TracebackType],
    ) -> None:
        if self.__response is not None:
            await self.__response.close()
